/*!
@page generator The QRestBuilder Tool

@brief The documentation for the qrestbuilder tool

@tableofcontents

@section generator_features What it does
The `qrestbuilder` reads in a xml file, and generates a header and a source from it. Those will, depending on the input, contain either
an "object", "gadget", "class" or "api". This allows an easy and fast creation of wrappers for any REST-API.
In order to use the tool as custom compiler, ou can simply create the XML files and add the to the pro file using
@code{.pro}
REST_API_FILES += # your xml files
@endcode

@section generator_start Getting Started
The easiest way to get started is to check out the JsonPlaceholderApi example. It will teach you the general system behind the generator.
You can then study this documentation to see, what you can do with it.

@section generator_doc File Syntax documentation
The following sections show a detailed documentation of what you can do with the tool, and explain the syntax of the xml files.
You can check the following locations for some sample files:
- [README.md](@ref index)
- `example/JsonPlaceholderApi`
- `tests/auto/restclient/RestBuilderTest`

There are also W3C XML Schema definitions available, see `tools/qrestbuilder/restclient.xsd` (TODO also attached to the end of this page).
Please note that while in the XSD sequences are used, generally the order of elements in the xml files can be whatever you want it to be.
The only elements where the order actually has any effect are the `<Path>/<PathParam>` elements of the `<Method>` element - but this is
specified in more detail in their documentation.

Your document must start with one of the following 4 root elements:
- `<RestObject>` - will generate an api object based on QObject
- `<RestGadget>` - will generate an api object based on Q_GADGET
- `<RestClass>` - will generate an api subclass
- `<RestApi>` - will generate the api root class<br/>

An object is simply a "data type" class. It will be generated with a bunch of properties (Q_PROPERTY), and methods to access them. They are
generated in an optimized way, an can be used by the rest client as data classes. It allows a simple, fast and easy creation of those objects.
You can generate them in two ways: As a Q_GADGET or a QObject. The gadget has the advantage of beeing a value type and using shared data, but
on the other side does not really allow inheritance and does not support change signals or dynamic properties, which the QObject classes do.

A class is a wrapper around QtRestClient::RestClass, that encapsulates the rather generic methods into custom methods with adjusted parameters etc.
This creates a c++ class, with simple methods to do HTTP-Request. In addition to that, you can build hieracical trees with classes, and those are
represented by methods in the classes, allowing you to follow that tree in c++ as well. For the "root-class", you can use the api version, which
allows you to specify the basic properties of a QtRestClient::RestClient.

@subsection generator_doc_RestObject Element Type: RestObject (and RestGadget)
The RestObject and RestGadget elements are of the same datatype and thus support the same attributes and children. The only difference is
how the final c++ code is beeing generated.

@subsubsection generator_doc_RestObject_attribs Attributes
 Name				| Allowed values		| Default/Required						| Description
--------------------|-----------------------|---------------------------------------|-------------
 name				| c++ class name		| <i>required</i>						| The class name of the generated class
 export				| string				| <i>none</i>							| Sepcify an export macro. The value is put before the class definition, if you want to export the generated classes from a dynamic library
 base				| name of a base class	| "QObject" for objects, "" for gadgets	| If you need a custom base class, use this property
 registerConverters	| bool					| true									| If true, automatically registers the list converters for this type
 testEquality		| bool					| true									| Setter methods check if the value did actually change before assigning it.<br/>This can fail if a used type does not have equality operators.
 generateEquals		| bool					| true for `RestGadget`, else false		| If enabled, default-generated equality operators are added
 generateReset		| bool					| true									| If enabled, reset methods are generated for all properties

@subsubsection generator_doc_RestObject_children Allowed Child Elements
 Name		| XML-Type									| Limits	| Description
------------|-------------------------------------------|-----------|-------------
 Include	| @ref generator_doc_Include "Include"		| 0 - ∞		| Additional header files to be included in the generated header
 Enum		| @ref generator_doc_Enum "Enum"			| 0 - ∞		| Custom enums to be created as part of the generated class
 Property	| @ref generator_doc_BaseParam "BaseParam"	| 1 - ∞		| The actual properties the class is composed of

@subsection generator_doc_RestClass Element Type: RestClass

@subsection generator_doc_RestApi Element Type: RestApi

@subsection generator_doc_Include Element Type: Include
Describes a file to be included via a c++ include directive. You can use them if you want to make use of special classes in your
generated classes. Both global includes (`#include <header>`) and local includes (`#include "header"`) are supported <br/>

@subsubsection generator_doc_Include_attribs Attributes
 Name	| Allowed values	| Default/Required	| Description
--------|-------------------|-------------------|-------------
 local	| bool				| false				| Specifies whether the include is a global or a local include

@subsubsection generator_doc_Include_content Content
The content of this element must be a string. More specific the header to be included. It becomes the content
of the include directive. Specifiy it without the braces or quores, as thoes are added automatically.

@subsection generator_doc_BaseParam Element Type: BaseParam
A base param is a method parameter or a Q_PROPERTY to be added to the generated class/method.
For each such property, getters and setters are generated as well, and depending on the configuration
even notify signals and reset methods. For method parameters, it determines the name and type of the
parameter, as well as the parameters default value, if wanted.

@subsubsection generator_doc_BaseParam_attribs Attributes
 Name	| Allowed values			| Default/Required	| Description
--------|---------------------------|-------------------|-------------
 key	| property/parameter name	| <i>required</i>	| The property or parameter name
 type	| c++ type name				| <i>required</i>	| The properties/parameters type
 asStr	| bool						| false				| Specify how the element content should be interpreted

@subsubsection generator_doc_BaseParam_content Content
The content of a base param is optional, and it represents the default value of the property/parameter.
If not specified, the base param will be initialize with it's default constructor. If specified, the content
is used to initialize (and reset) the base param. How the content is interpreted depends on the `asStr` attribute.

If it is set to false (the default), the content must be c++ code and is copied to the generated class as is. The
code must be an expression that evalutes to a single value that is implicitly convertible to the given `type`. If
type was for example `int`, valid expressions could be:
- `-1`
- `10 + 20`
- `qRand()`

If set to true, the content is assumed to be a string. You don't need to specify quotation marks around the string.
That string is used to initialize a QVariant that is then converted to `type` - in other words, the type you use must be
variant convertible from a string. This can be used to, for example, create a `QDate` from a string with the default
value of `2018-05-09`.

@subsection generator_doc_Enum Element Type: Enum
If you want to use custom enum types in you class, use this element. It allows you to generate enums and flags
that are automatically registered with Qt.

@subsubsection generator_doc_Enum_attribs Attributes
 Name		| Allowed values				| Default/Required	| Description
------------|-------------------------------|-------------------|-------------
 name		| c++ class name				| <i>required</i>	| The c++ name of the generated enum
 base		| name of a valid parent class	| <i>none</i>		| If you need a custom base class for your enum, use this property. But remember that Qt discourages this!
 isFlags	| bool							| false				| If set to true, a QFlag type is generated and registered instead of a normal enum

@subsubsection generator_doc_Enum_children Allowed Child Elements
Name	| XML-Type								| Limits	| Description
--------|---------------------------------------|-----------|-------------
Key		| @ref generator_doc_EnumKey "EnumKey"	| 1 - ∞		| The actual elements of the enum/flags to be generated

@subsection generator_doc_EnumKey Element Type: EnumKey
Describes a key/element within an enum.

@subsubsection generator_doc_EnumKey_attribs Attributes
 Name	| Allowed values	| Default/Required	| Description
--------|-------------------|-------------------|-------------
 name	| c++ enum key name	| <i>required</i>	| The name of the key, i.e. the actual enum key.

@subsubsection generator_doc_EnumKey_content Content
The content is optional. You can specify a custom value for your enum element (is placed after the = sign). The content
must be a valid c++ constexpr, i.e. code that can be evaluated at compile time and that results in a value of the base
type your enum is of (Or int, if no base type is given).

@subsection generator_doc_Expression Element Type: Expression

@subsection generator_doc_FixedParam Element Type: FixedParam

@subsection generator_doc_Class Element Type: Class

@subsection generator_doc_Method Element Type: Method

@subsection generator_doc_BaseUrl Element Type: BaseUrl








## Generate classes {#generator_doc_class}
Classes are added to the pro file by using the REST_API_CLASSES variable. A class is a wrapper around QtRestClient::RestClass, that encapsulates the
rather generic methods into custom methods with adjusted parameters etc. This creates a c++ class, with simple methods to do HTTP-Request. In addition
to that, you can build hieracical trees with classes, and those are represented by methods in the classes, allowing you to follow that tree in c++ as well.
For the "root-class", you can use the api version, which allows you to specify the basic properties of a QtRestClient::RestClient.

Your JSON files will need to have the following structure:

### Type: class {#generator_doc_c_class}
The root element of any object to be generated. depending on the `type` you choose, it will be extended by some additional properties.

All types allow the following elements:

 Name		| Allowed values							| Default/Required	| Description
------------|-------------------------------------------|-------------------|--------------------------------------------------------------------
 type		| "api" or "class"							| "class"			| Define the type to generate - a class or an api
 name		| any valid c++ class name					| file name			| The class name of the generated class
 includes	| list of strings							| []				| specify a list of includes for the header file.<br>By default, the are included with `<...>`. To include as `"..."`, prepend "&gt;" to the include.<br>(Example: `>myClass.h` to get `#include "myClass.h"` instead of `#include <myClass.h>`)
 export		| string									| <i>none</i>		| Sepcify an export macro. The value is put before the class definition, if you want to export the generated classes
 parent		| name of a valid parent class				| "QObject"			| If you need a custom parent, use this property
 except		| The default execpt value					| "QObject*"		| The default value for "except" of all [method](#generator_doc_c_method) elements
 classes	| [classes-object](#generator_doc_c_cobj)	| {}				| The child-classes. See [Type: classes-object](#generator_doc_c_cobj)
 methods	| [methods-object](#generator_doc_c_mobj)	| {}				| The child-methods. See [Type: methods-object](#generator_doc_c_mobj)

If the type is `class` the following properties are available as well:

 Name		| Allowed values					| Default/Required	| Description
------------|-----------------------------------|-------------------|--------------------------------------------------------------------
 path		| [expression](#generator_doc_expr)	| ""				| Set the path of this class, relative to **it's parent**. Empty means same as parent

If the type is `api` the following properties are available as well:

 Name		| Allowed values							| Default/Required	| Description
------------|-------------------------------------------|-------------------|--------------------------------------------------------------------
 baseUrl	| URL ([expression](#generator_doc_expr))	| <i>required</i>	| The base URL of the API. Will be set as QtRestClient::RestClient::baseUrl
 apiVersion	| version [expression](#generator_doc_expr)	| no version		| The version of the API. Will be set as QtRestClient::RestClient::apiVersion
 parameters	| object									| {}				| Parameters in key-value format. Will be set as QtRestClient::RestClient::globalParameters. Values are of type [expression](#generator_doc_expr)
 headers	| object									| {}				| Headers in key-value format. Will be set as QtRestClient::RestClient::globalHeaders, UTF-8 encoded. Values are of type [expression](#generator_doc_expr)
 globalName	| [expression](#generator_doc_expr)			| none				| If specified, the API will be registered by that name using QtRestClient::addGlobalApi
 autoCreate	| bool										| true				| <i>Requires `globalName` to be set.</i> If set to true, the API will be automatically registered on application start. If not, it happens on first use

### Type: classes-object {#generator_doc_c_cobj}
This type allows you to add "child-classes" to your class/api in form of key-value pairs. The key is the name of the
method in your class that should return the class. The Value is the class type. You will have to add it as include. The
type must be class generated by the tool as well. It is possible to use an api as child class as well, but it will ignore
the API-aspect, and simply interpret it as class. However, it is not recommended to do so.

The following snippet shows an example. It assumes an `myclass.json`, holding a class definition with name `MyClass`:
@code{.json}
{
	"include": ["myclass.h", ...]
	"classes": {
		"myClass": "MyClass",
		...
	}
}
@endcode

### Type: Expressions {#generator_doc_expr}
In the following sections, you will often find `expression` as a type. This allows you to enter c++ expressions where strings are expected. An expression can
either be interpret as a string or as an expression.

If you pass a normal string, i.e. `"myString"`, it is interpreted as a string. In the generated code, the json string will be put as is.

If you however prepend the `$`-sign, it becomes an expression. As an expression, whatever comes after the $, will be used as C++ code, and not as a string.
For Example, `"$MyClass::myFunction()"` will insert the function call `MyClass::myFunction()`, instead of a string. You can escape strings in this synax using
`$myFunc(\"string\")`. An expression can contain anything, as long as the result is compilable. You may need to add additional includes for your expressions.

### Type: methods-object {#generator_doc_c_mobj}
The main aspect of your class are the methods. They define what can be done by your class. The define a HTTP-request, that will
be wrapped into a c++ method by the builder. Like most other elements, the methods are key-value pairs as well, with the key
beeing the methods name, and the value a `method-object`, that can contain the following elements:

 Name		| Allowed values								| Default/Required							| Description
------------|-----------------------------------------------|-------------------------------------------|--------------------------------------------------------------------
 path		| [expression](#generator_doc_expr)				| none										| A subpath, append to the classes path. **must not be combined with `url`**
 url		| URL ([expression](#generator_doc_expr))		| none										| A (relative) url, resolved to the classes path. **must not be combined with `path`**
 verb		| HTTP-Verb ([expression](#generator_doc_expr))	| "GET"										| The HTTP-Verb to be used for the request
 body		| name of a c++ object							| none										| An optional body, to be sent with the request. Must be serializable and included
 pathParams	| [param-list](#generator_doc_param)			| []										| A list of parameters, where each parameter becomes a segment, appended to the requests path. See [Type: param-list](#generator_doc_param)
 parameters	| [param-list](#generator_doc_param)			| []										| A list of parameters, added as QUrlQuery parameters. See [Type: param-list](#generator_doc_param)
 headers	| object										| {}										| Headers in key-value format. Will be added as additional HTTP-Headers, UTF-8 encoded. Values are of type [expression](#generator_doc_expr)
 returns	| name of a c++ object							| "QObject*"								| The type of the reply entity. Must be serializable and included, or void
 except		| name of a c++ object							| [class](#generator_doc_c_class).except	| The type of a reply with an error. Must be serializable and included. Defaults to the classes except property

If neither `path` nor `url` are specified, the request will use the classes path without modifications

### Type: param-list {#generator_doc_param}
In order to specify parameters, that are added to the method in the same order they have been specified, a param-list is used.
It's a list of strings, were each string has the format `<name>;<type>[;<default>]`. The name will be the name of the parameter, and type
it's type. Please note that the type must be convertible to string via QVariant. The default part is optional, and ca be used to provide a default
argument for the parameter. Please note that the rules of default arguments of C++ apply here. See http://en.cppreference.com/w/cpp/language/default_arguments

The following snippet shows an example of such parameters:
@code{.json}
{
	"include": ["QDateTime", ...]
	"parameters": [
		"id;int",
		"name;QString",
		"date;QDateTime"
	]
}
@endcode
*/
